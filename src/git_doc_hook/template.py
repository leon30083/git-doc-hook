"""Template rendering module for git-doc-hook

Provides Jinja2-based template rendering with graceful fallback.
"""
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class TemplateRenderer:
    """Jinja2 template renderer for documentation generation

    Loads templates from the builtin templates directory or custom locations.
    Provides graceful fallback if Jinja2 is not available.
    """

    # Builtin template directory
    BUILTIN_TEMPLATE_DIR = Path(__file__).parent.parent / "templates" / "prompts"

    # Template names
    TEMPLATE_TRADITIONAL = "traditional.md.j2"
    TEMPLATE_CONFIG_RULE = "config_rule.md.j2"
    TEMPLATE_MEMO = "memo.md.j2"

    def __init__(
        self,
        template_dir: Optional[Path] = None,
        use_builtin: bool = True,
        enabled: bool = True,
    ):
        """Initialize template renderer

        Args:
            template_dir: Custom template directory (overrides builtin)
            use_builtin: Whether to use builtin templates as fallback
            enabled: Whether template rendering is enabled
        """
        self.template_dir = Path(template_dir) if template_dir else None
        self.use_builtin = use_builtin
        self.enabled = enabled
        self._jinja_env = None

        if self.enabled:
            self._init_jinja()

    def _init_jinja(self) -> None:
        """Initialize Jinja2 environment"""
        try:
            import jinja2

            # Create loader with template paths
            loader_paths = []
            if self.template_dir and self.template_dir.exists():
                loader_paths.append(str(self.template_dir))
            if self.use_builtin and self.BUILTIN_TEMPLATE_DIR.exists():
                loader_paths.append(str(self.BUILTIN_TEMPLATE_DIR))

            if loader_paths:
                self._jinja_env = jinja2.Environment(
                    loader=jinja2.FileSystemLoader(loader_paths),
                    autoescape=False,
                    trim_blocks=True,
                    lstrip_blocks=True,
                )
                logger.debug(f"Jinja2 initialized with paths: {loader_paths}")
            else:
                logger.warning("No template directories found")
        except ImportError:
            logger.warning("Jinja2 not available, using fallback rendering")
            self._jinja_env = None

    def render(self, template_name: str, context: Dict[str, Any]) -> str:
        """Render a template with the given context

        Args:
            template_name: Name of the template file
            context: Template variables

        Returns:
            Rendered content string
        """
        if not self.enabled:
            return self._fallback_render(template_name, context)

        if self._jinja_env is None:
            return self._fallback_render(template_name, context)

        try:
            template = self._jinja_env.get_template(template_name)
            return template.render(**context)
        except Exception as e:
            logger.warning(f"Template rendering failed for {template_name}: {e}")
            return self._fallback_render(template_name, context)

    def _fallback_render(self, template_name: str, context: Dict[str, Any]) -> str:
        """Fallback simple text rendering

        Args:
            template_name: Template name (for context)
            context: Template variables

        Returns:
            Simple formatted string
        """
        lines = [
            f"# Documentation Update",
            f"",
            f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"",
        ]

        # Add project info
        if "project_name" in context:
            lines.append(f"Project: {context['project_name']}")
        if "commit_message" in context:
            lines.append(f"Commit: {context['commit_message']}")
        if "commit_hash" in context:
            lines.append(f"Hash: {context['commit_hash']}")

        lines.append("")

        # Add changed files
        if "changed_files" in context and context["changed_files"]:
            lines.append("## Changed Files")
            for file in context["changed_files"]:
                lines.append(f"- {file}")
            lines.append("")

        # Add updates
        if "updates" in context and context["updates"]:
            lines.append("## Updates")
            for update in context["updates"]:
                target = update.get("target", "unknown")
                action = update.get("action", "unknown")
                lines.append(f"- **{target}**: {action}")
            lines.append("")

        lines.append("*Generated by git-doc-hook*")
        return "\n".join(lines)

    def build_context(
        self,
        project_path: Path,
        pending_update: Any,
        config: Any,
        git_info: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Build template context from project state

        Args:
            project_path: Path to project
            pending_update: PendingUpdate object
            config: Config object
            git_info: Optional additional git information

        Returns:
            Template context dictionary
        """
        git_info = git_info or {}

        # Get repository info
        try:
            from core.git import GitManager

            git = GitManager(str(project_path))
            branch = git.get_current_branch()
            repo_url = git.get_remote_url() or "local"
        except Exception:
            branch = "main"
            repo_url = "local"

        # Analyze changed files
        services = []
        for file_path in pending_update.files:
            file_info = self._analyze_file(project_path / file_path, file_path)
            if file_info:
                services.append(file_info)

        # Build action list from config
        updates = []
        for file_path in pending_update.files:
            for rule in config.get_rules_for_pattern(file_path):
                for action in rule.get("actions", []):
                    updates.append({
                        "target": action.get("target", ""),
                        "section": action.get("section", ""),
                        "action": action.get("action", ""),
                        "content": action.get("content", ""),
                    })

        return {
            "project_name": project_path.name,
            "repo_url": repo_url,
            "branch": branch,
            "commit_hash": pending_update.triggered_by[:8] if pending_update.triggered_by else "unknown",
            "commit_message": pending_update.commit_message,
            "changed_files": pending_update.files,
            "services": services,
            "updates": updates,
            "reason": pending_update.reason,
            "timestamp": datetime.fromtimestamp(pending_update.timestamp).isoformat(),
        }

    def _analyze_file(self, full_path: Path, relative_path: str) -> Optional[Dict[str, Any]]:
        """Analyze a file to extract information

        Args:
            full_path: Full path to file
            relative_path: Relative path from project root

        Returns:
            File info dict or None
        """
        if not full_path.exists():
            return None

        try:
            from analyzers import get_analyzer
            from analyzers.base import AnalysisResult

            analyzer = get_analyzer(str(full_path))
            if analyzer:
                result: AnalysisResult = analyzer.analyze(str(full_path))

                return {
                    "name": full_path.stem,
                    "file": relative_path,
                    "type": self._get_file_type(relative_path),
                    "status": "modified" if full_path.exists() else "deleted",
                    "language": result.language,
                    "complexity": result.complexity.to_dict() if result.complexity else None,
                }
        except Exception as e:
            logger.debug(f"Failed to analyze {full_path}: {e}")

        return {
            "name": full_path.stem,
            "file": relative_path,
            "type": self._get_file_type(relative_path),
            "status": "modified",
            "language": "unknown",
        }

    def _get_file_type(self, file_path: str) -> str:
        """Determine file type from path

        Args:
            file_path: File path

        Returns:
            File type string
        """
        path = Path(file_path)
        parent_lower = path.parent.name.lower()

        if "service" in parent_lower:
            return "service"
        if "model" in parent_lower or "entity" in parent_lower:
            return "model"
        if "controller" in parent_lower:
            return "controller"
        if "util" in parent_lower or "helper" in parent_lower:
            return "utility"
        if "test" in parent_lower or path.name.startswith("test_"):
            return "test"
        if "config" in parent_lower or path.name.endswith(".config.js"):
            return "config"

        return "module"

    def render_traditional(self, context: Dict[str, Any]) -> str:
        """Render traditional documentation template

        Args:
            context: Template context

        Returns:
            Rendered content
        """
        return self.render(self.TEMPLATE_TRADITIONAL, context)

    def render_config_rule(self, context: Dict[str, Any]) -> str:
        """Render config rule documentation template

        Args:
            context: Template context

        Returns:
            Rendered content
        """
        return self.render(self.TEMPLATE_CONFIG_RULE, context)

    def render_memo(self, context: Dict[str, Any]) -> str:
        """Render MemOS record template

        Args:
            context: Template context

        Returns:
            Rendered content
        """
        return self.render(self.TEMPLATE_MEMO, context)


def create_renderer(project_path: Path, config: Any) -> TemplateRenderer:
    """Create a template renderer from project config

    Args:
        project_path: Path to project
        config: Config object

    Returns:
        Configured TemplateRenderer
    """
    template_dir = Path(config.get("templates.dir", "~/.git-doc-hook/templates")).expanduser()
    use_builtin = config.get("templates.use_builtin", True)
    enabled = config.get("templates.enabled", True)

    return TemplateRenderer(
        template_dir=template_dir if template_dir.exists() else None,
        use_builtin=use_builtin,
        enabled=enabled,
    )
